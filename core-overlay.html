<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="core-key-helper.html">

<!--
/**
 * @module Core Elements
 */
/**
 * core-overlay displays overlayed on top of other content. It starts
 * out hidden and is displayed by setting it's opened property to true.
 * A core-overlay's opened state can be toggled by calling the toggle
 * method.
 * 
 * It's common to want a core-overlay to animate to its opened
 * position. A number of helper css classes provide some basic open/close
 * animations. For example, assigning the class core-overlay-fade to a
 * core-overlay will make it fade into and out of view as it opens and
 * closes. Note, if multiple core-overlay's are opened, they should
 * stack on top of each other.
 * 
 * Styling: The size and position of a core-overlay should be setup
 * via css.
 * core-overlay is natually sized around its content. When a
 * core-overlay is opened it is shown and the 'opened' class is added
 * to it. This is typically where css transitions and animations are
 * applied. When the core-overlay is closed, the 'opened' class is
 * removed and a 'closing' class is added. Use 'closing' to customize
 * the closing animation. 
 * 
 * Classes for animating core-overlay:
 * 
 * * core-overlay-fade: fade in/out when opened/closed
 * * core-overlay-scale-slideup: open: fade in and shrink;
 * close: slide up
 * * core-overlay-shake: open: fly in and shake; close: shake and
 * fly out.
 *
 * It's common to use core-overlay to gather user input, for example
 * a login dialog. To facilitate this, core-overlay supports automatic
 * focusing of a specific element when it's opened. The element to be
 * focused should be given an autofocus attribute.
 * 
 * An element that should close the core-overlay will automatically
 * do so if it is given the overlay-toggle attribute. Please note that
 * core-overlay will close whenever the user taps outside it or
 * presses the escape key. The behavior can be turned off via the
 * autoCloseDisabled property.
 * 
 *     <div>
 *       <core-overlay></core-overlay>
 *       <h2>Dialog</h2>
 *       <input placeholder="say something..." autofocus>
 *       <div>I agree with this wholeheartedly.</div>
 *       <button overlay-toggle>OK</button>
 *     </div>
 * 
 * @class core-overlay
 */
/**
 * Fired when the core-overlay opened property is set.
 * 
 * @event core-overlay-open
 * @param {Object} inDetail
 * @param {Object} inDetail.opened the opened state
 */
-->

<polymer-element name="core-overlay" attributes="target opened autoCloseDisabled">
  
  <template>
    <link rel="stylesheet" href="core-overlay.css">
    <link rel="stylesheet" href="core-overlay-controller.css">
  </template>
  
  <script>
    (function() {
    
      Polymer('core-overlay', {
        
        /**
         * The target element.
         *
         * @attribute target
         * @type Object
         */
        target: null,
        
        /**
         * Set opened to true to show an overlay and to false to hide it.
         * A core-overlay may be made intially opened by setting its
         * opened attribute.
         * @attribute opened
         * @type boolean
         * @default false
         */
        opened: false,
        
        /**
         * By default an overlay will close automatically if the user
         * taps outside it or presses the escape key. Disable this
         * behavior by setting the autoCloseDisabled property to true.
         * @attribute autoCloseDisabled
         * @type boolean
         * @default false
         */
        autoCloseDisabled: false,
        
        /**
         * Timeout which will cause any open or close animation to complete.
         *
         * @attribute timeout
         * @type integer
         * @default 1000
         */
        timeout: 1000,
        
        captureEventType: 'tap',
        
        registerCallback: function(element) {
          this.keyHelper = document.createElement('core-key-helper');
          var content = element.templateContent();
          this.overlayStyle = content.firstElementChild;
          this.controllerStyle = content.lastElementChild;
        },

        fetchTemplate: function() {
          return null;
        },

        /** 
         * Toggle the opened state of the overlay.
         * @method toggle
         */
        toggle: function() {
          this.opened = !this.opened;
        },

        targetChanged: function(old) {
          // we need this since we call targetChanged synchronously
          if (old === this.target) {
            return;
          }
          if (this.target) {
            if (this.target.tabIndex === -1) {
              this.target.tabIndex = 0;
            }
            this.target.classList.add('core-overlay');
            this.addListeners(this.target);
          }
          if (old) {
            old.classList.remove('core-overlay');
            this.removeListeners(old);
          }
          this.ensureStyle();
        },

        ensureStyle: function() {
          if (this.target === this) {
            if (!this._hasOverlayStyle) {
              this._hasOverlayStyle = true;
              this.createShadowRoot().appendChild(
                  this.overlayStyle.cloneNode(true));
            }
          } else if (!this.target._hasControllerStyle) {
            this.target._hasControllerStyle = true;
            this.installScopeStyle(this.controllerStyle, 'overlay', this.target);
          }
        },

        listeners: {
          'tap': 'tapHandler',
          'keydown': 'keydownHandler'
        },

        addListeners: function(node) {
          for (e in this.listeners) {
            node.addEventListener(e, this[this.listeners[e]].bind(this));
          }
        },

        removeListeners: function(node) {
          for (e in this.listeners) {
            node.removeEventListener(e, this[this.listeners[e]].bind(this));
          }
        },

        openedChanged: function() {
          if (!this.target) {
            this.target = this;
            this.targetChanged();
          }

          this.renderOpened();
          trackOverlays(this);
          this.async(function() {
            if (!this.autoCloseDisabled) {
              this.enableCaptureHandler(this.opened);
            }
          });
          this.enableResizeHandler(this.opened);
          this.fire('core-overlay-open', this.opened);
        },

        enableHandler: function(inEnable, inMethodName, inNode, inEventName, inCapture) {
          var m = 'bound' + inMethodName;
          this[m] = this[m] || this[inMethodName].bind(this);
          
          inNode[inEnable ? 'addEventListener' : 'removeEventListener'](
            inEventName, this[m], inCapture);
        },

        enableResizeHandler: function(inEnable) {
          this.enableHandler(inEnable, 'resizeHandler', window, 
            'resize');
        },

        enableCaptureHandler: function(inEnable) {
          this.enableHandler(inEnable, 'captureHandler', document, 
            this.captureEventType, true);
        },

        getFocusNode: function() {
          return this.target.querySelector('[autofocus]') || this.target;
        },

        // TODO(sorvell): nodes stay focused when they become un-focusable
        // due to an ancestory becoming display: none; file bug.
        applyFocus: function() {
          var focusNode = this.getFocusNode();
          if (this.opened) {
            focusNode.focus();
          } else {
            focusNode.blur();
            focusOverlay();
          }
        },

        positionTarget: function() {
          if (this.opened) {
            // vertically and horizontally center if not positioned
            var computedStyle = getComputedStyle(this.target);
            var boundingRect = this.target.getBoundingClientRect();
            if (computedStyle.top === 'auto' && computedStyle.bottom === 'auto') {
              this.target.style.top = ((window.innerHeight - boundingRect.height) / 2) + 'px';
            }
            if (computedStyle.left === 'auto' && computedStyle.right === 'auto') {
              this.target.style.left = ((window.innerWidth - boundingRect.width) / 2) + 'px';
            }
          }
        },

        resetTargetPosition: function() {
          this.target.style.top = this.target.style.left = null;
        },

        renderOpened: function() {
          this.target.classList.add('core-revealed');
          // continue styling after delay so display state can change
          // without aborting transitions
          this.async('continueRenderOpened');
        },

        continueRenderOpened: function() {
          this.positionTarget();
          this.target.classList.toggle('core-opened', this.opened);
          this.async('completeOpening');
        },

        completeOpening: function() {
          //this.target.classList.remove('core-animating');
          this.target.classList.toggle('core-revealed', this.opened);
          if (!this.opened) {
            this.resetTargetPosition();
          }
          this.applyFocus();
        },

        tapHandler: function(e) {
          if (e.target && e.target.hasAttribute('overlay-toggle')) {
            this.toggle();
          } else {
            if (this.autoCloseJob) {
              this.autoCloseJob.stop();
              this.autoCloseJob = null;
            }
          }
        },

        // TODO(sorvell): This approach will not work with modal. For
        // this we need a scrim.
        captureHandler: function(e) {
          if (!this.autoCloseDisabled && (currentOverlay() == this) && (this 
              != e.target) && !(this.contains(e.target))) {
            this.autoCloseJob = this.job(this.autoCloseJob, function() {
              this.opened = false;
            });
          }
        },

        keydownHandler: function(e) {
          if (!this.autoCloseDisabled && (e.keyCode == this.keyHelper.ESCAPE_KEY)) {
            console.log(e.target);
            this.opened = false;
            e.stopPropagation();
          }
        },

        /**
         * Extensions of core-overlay should implement the resizeHandler
         * method to adjust the size and position of the overlay when the 
         * browser window resizes.
         * @method resizeHandler
         */
        resizeHandler: function() {
        }
      });

      // track overlays for z-index and focus managemant
      var overlays = [];
      var trackOverlays = function(inOverlay) {
        if (inOverlay.opened) {
          //var overlayZ = window.getComputedStyle(inOverlay.target).zIndex;
          //var z0 = Math.max(currentOverlayZ(), overlayZ);
          var z0 = currentOverlayZ();
          overlays.push(inOverlay);
          var z1 = currentOverlayZ();
          if (z1 <= z0) {
            applyOverlayZ(inOverlay, z0);
          } 
        } else {
          var i = overlays.indexOf(inOverlay);
          if (i >= 0) {
            overlays.splice(i, 1);
            setZ(inOverlay, null);
          }
        }
      }
      
      var applyOverlayZ = function(inOverlay, inAboveZ) {
        setZ(inOverlay.target, inAboveZ + 2);
      }
      
      var setZ = function(inNode, inZ) {
        inNode.style.zIndex = inZ;
      }
    
      var currentOverlay = function() {
        return overlays[overlays.length-1];
      }
      
      var DEFAULT_Z = 10;
      
      var currentOverlayZ = function() {
        var z;
        var current = currentOverlay();
        if (current) {
          var z1 = window.getComputedStyle(current.target).zIndex;
          if (!isNaN(z1)) {
            z = Number(z1);
          }
        }
        return z || DEFAULT_Z;
      }
      
      var focusOverlay = function() {
        var current = currentOverlay();
        if (current) {
          current.applyFocus();
        }
      }
    })();
  </script>
</polymer-element>
